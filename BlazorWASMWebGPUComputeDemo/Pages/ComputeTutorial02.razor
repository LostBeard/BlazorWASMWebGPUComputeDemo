@* @page "/webgpu-compute-basics"

<PageTitle>WebGPU Compute Tutorial 2 Demo</PageTitle>

<h1>WebGPU Compute Tutorial 2 Demo</h1>

<div style="padding: 1rem;">
    <p>This demo is based off the tutorial linked below.</p>
    <a href="https://webgpufundamentals.org/webgpu/lessons/webgpu-compute-shaders.html">WebGPU Compute Shader Basics</a>
    <p>

    </p>
</div>
<div style="padding: 1rem;">
    <button class="btn btn-primary" disabled="@_running" @onclick="Run">Run</button>
</div>
<div style="padding: 1rem;">
    <pre>
        @_log
    </pre>
</div>

@code {
    [Inject]
    BlazorJSRuntime JS { get; set; } = default!;

    string _log = "Ready";
    bool _running = false;

    void Log(string msg = "", bool clear = false)
    {
        if (clear) _log = "";
        _log += msg + "\n";
        StateHasChanged();
    }

    private async Task Run()
    {
        if (_running) return;
        _running = true;
        try
        {
            Log(clear: true);

            var adapter = JS.IsUndefined("navigator.gpu?.requestAdapter") ? null : await JS.CallAsync<GPUAdapter>("navigator.gpu.requestAdapter");
            if (adapter == null)
            {
                Log("WebGPU not supported");
                return;
            }
            using var device = await adapter.RequestDevice();
            if (device == null)
            {
                Log("WebGPU not supported");
                return;
            }
            Log("WebGPU supported");


            var workgroupSize = new int[] { 1,2,3 };

            using var module = device.CreateShaderModule(new GPUShaderModuleDescriptor
            {
                Label = "doubling compute module",
                Code = $@"

            });

            using var pipeline = device.CreateComputePipeline(new GPUComputePipelineDescriptor
            {
                Label = "doubling compute pipeline",
                Layout = GPUAutoLayoutMode.Auto,
                Compute = new GPUProgrammableStage
                {
                    Module = module,
                }
            });

            // input data
            var input = new float[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            Log($@"Input: {string.Join(", ", input)}");


            using var inputFloatArray = new Float32Array(input);
            var inputByteLength = inputFloatArray.ByteLength;

            // create a buffer on the GPU to hold our computation
            // input and output
            using var workBuffer = device.CreateBuffer(new GPUBufferDescriptor
            {
                Label = "work buffer",
                Size = (ulong)inputByteLength,
                Usage = GPUBufferUsage.Storage | GPUBufferUsage.CopySrc | GPUBufferUsage.CopyDst,
            });

            // Copy our input data to that buffer
            device.Queue.WriteBuffer(workBuffer, 0, inputFloatArray);

            using var resultBuffer = device.CreateBuffer(new GPUBufferDescriptor
            {
                Label = "result buffer",
                Size = (ulong)inputByteLength,
                Usage = GPUBufferUsage.MapRead | GPUBufferUsage.CopyDst
            });

            using var bindGroup = device.CreateBindGroup(new GPUBindGroupDescriptor
            {
                Label = "bindGroup for work buffer",
                Layout = pipeline.GetBindGroupLayout(0),
                Entries = new GPUBindGroupEntry[] {
                    new GPUBindGroupEntry
                    {
                        Binding = 0,
                        Resource = new GPUBufferBinding{ Buffer = workBuffer }
                    }
                },
            });

            // Encode commands to do the computation
            using var encoder = device.CreateCommandEncoder(new GPUCommandEncoderDescriptor
            {
                Label = "doubling encoder",
            });

            using var pass = encoder.BeginComputePass(new GPUComputePassDescriptor
            {
                Label = "doubling compute pass",
            });
            pass.SetPipeline(pipeline);
            pass.SetBindGroup(0, bindGroup);
            pass.DispatchWorkgroups((uint)inputByteLength);
            pass.End();

            // Encode a command to copy the results to a mappable buffer.
            encoder.CopyBufferToBuffer(workBuffer, 0, resultBuffer, 0, resultBuffer.Size);

            // Finish encoding and submit the commands
            using var commandBuffer = encoder.Finish();
            device.Queue.Submit([commandBuffer]);

            // Read the results
            await resultBuffer.MapAsync(GPUMapMode.Read);
            using var outputFloatArray = new Float32Array(resultBuffer.GetMappedRange());

            float[] output = outputFloatArray.ToArray();
            Log($@"Result: {string.Join(", ", output)}");

            resultBuffer.Unmap();
        }
        finally
        {
            _running = false;
            StateHasChanged();
        }
    }


    private int GiveMandelNumber(double x, double y, int _iterations = 400)
    {
        var mandelNumber = 0;
        double a = 0, aOld = 0, b = 0, c = 0;
        while (c <= 4 && mandelNumber < _iterations)
        {
            a = a * a - b * b + x;
            b = 2 * aOld * b + y;
            aOld = a;
            c = a * a + b * b;
            mandelNumber++;
        }
        return mandelNumber;
    }

    // void Mandelbrot()
    // {
    //     (int x, int y) xyStep = (1, 1);
    //     var yMin = 0;
    //     var xMin = 0;
    //     var yMax = 0;
    //     var xMax = 0;
    //     var kLast = 0;
    //     var kMin = 0;
    //     var kMax = 1;
    //     var color = 0;
    //     var colorLast = 0;
    //     var modulusSquared = 0;
    //     for (double y = yMin; y < yMax; y += xyStep.y)
    //     {
    //         int xPix = 0;
    //         for (double x = xMin; x < xMax; x += xyStep.x)
    //         {
    //             ComplexPoint c = new ComplexPoint(x, y);
    //             ComplexPoint zk = new ComplexPoint(0, 0);
    //             int k = 0;
    //             do
    //             {
    //                 zk = zk.doCmplxSqPlusConst(c);
    //                 modulusSquared = zk.doMoulusSq();
    //                 k++;
    //             } while ((modulusSquared <= 4.0) && (k < kMax));

    //             if (k < kMax)
    //             {
    //                 if (k == kLast)
    //                 {
    //                     color = colorLast;
    //                 }
    //                 else
    //                 {
    //                     color = colourTable.GetColour(k);
    //                     colorLast = color;
    //                 }

    //                 if (xyPixelStep == 1)
    //                 {
    //                     if ((xPix < myBitmap.Width) && (yPix >= 0))
    //                     {
    //                         myBitmap.SetPixel(xPix, yPix, color);
    //                     }
    //                 }
    //                 else
    //                 {
    //                     for (int pX = 0; pX < xyPixelStep; pX++)
    //                     {
    //                         for (int pY = 0; pY < xyPixelStep; pY++)
    //                         {
    //                             if (((xPix + pX) < myBitmap.Width) && ((yPix - pY) >= 0))
    //                             {
    //                                 myBitmap.SetPixel(xPix + pX, yPix - pY, color);
    //                             }
    //                         }
    //                     }
    //                 }
    //             }
    //             xPix += xyPixelStep;
    //         }
    //         yPix -= xyPixelStep;
    //     }
    }
}
 *@
@page "/mandelbrot"
@using BlazorWASMWebGPUComputeDemo.Fractals
@using System.Diagnostics
@using SpawnDev.BlazorJS.Toolbox
@using SpawnDev.BlazorJS.WebWorkers
@implements IDisposable

<PageTitle>Mandelbrot</PageTitle>

<h1>Mandelbrot</h1>

<div style="padding: 0.5rem;">
</div>
<div style="padding: 0.5rem;">
    <button class="btn btn-primary" disabled="@_running" @onclick="Run">Run</button>
    <button class="btn btn-primary" disabled="@_running" @onclick="RunWithWorkers">Run with Workers</button>
    <button class="btn btn-primary" disabled="@_running" @onclick="@(() => WriteData(false))">Write Data</button>
    <button class="btn btn-primary" disabled="@_running" @onclick="@(() => WriteData(true))">Write Data with HeapView</button>
</div>
<div style="padding: 0.5rem;">
    <pre>
        @_log
    </pre>
</div>
<div style="padding: 0.5rem;">
    <canvas style="border: 1px solid black; max-width: 600px; max-height: 600px;" @ref=canvasRef width="600" height="600"></canvas>
</div>

@code {
    [Inject]
    BlazorJSRuntime JS { get; set; } = default!;

    [Inject]
    WebWorkerService WebWorkerService { get; set; } = default!;

    ElementReference canvasRef;

    HTMLCanvasElement? canvas;
    CanvasRenderingContext2D? ctx;

    string _log = "Ready";
    bool _running = false;
    int placeIndex = 1;
    MandelbrotPlace place => places[placeIndex];

    List<MandelbrotPlace> places = new List<MandelbrotPlace>(new[] {
        new MandelbrotPlace("Default", -0.5, 0, 0.0025, 400, 2, 2, 3, 5),
        new MandelbrotPlace("Waves", -0.59836573600769, -0.664236764907637, 1.9073486328125E-08, 2400, 2, 2, 3, 5),
        new MandelbrotPlace("Weird DNA", 0.384192199707031, -0.0985696411132812, 0.762939453125E-07, 800, 2, 10, 1, 5),
        new MandelbrotPlace("Dinosaur", -0.531610422134399, -0.668436431884766, 4.76837158203125E-09, 2200, 2, 6, 8, 1),
        new MandelbrotPlace("Bat", -0.53160898680031, -0.668437485636351, 1.818989403545855E-14, 2200, 2, 4, 7, 3),
        new MandelbrotPlace("Paint splash", -1.94141374199284, -0.00502002773871919, 0.90949470177293E-14, 400, 2, 1, 3, 5),
        new MandelbrotPlace("Hypnotic", -0.7464555, 0.1151315, 1.875E-06, 3000, 2, 5, 8, 10),
        new MandelbrotPlace("Back2Black", -1.27832725032806, 0.0724904097795486, 4.053115844726565E-11, 850, 2, 1, 1, 1)
    });

    byte[]? __data;
    async Task WriteData(bool useHeapView)
    {
        if (canvas == null || ctx == null) return;
        var w = 8000;
        var h = 8000;
        var length = w * h * 4;
        if (__data?.Length != length)
        {
            __data = new byte[w * h * 4];
            for (var i = 0; i < __data.Length; i += 4)
            {
                __data[i] = (byte)i;
                __data[i + 1] = (byte)(255 - i);
                __data[i + 2] = (byte)(255 - i);
                __data[i + 3] = (byte)255;
            }
        }
        canvas.Width = w;
        canvas.Height = h;
        await Log("Running...", clear: true);
        var sw = Stopwatch.StartNew();
        if (useHeapView)
        {
            // no copy made. the heapView is  sent directly to the browser API which copies it internally before returning
            ctx.PutImageBytes(__data, w, h);
        }
        else
        {
            // this creates a copy of __data when it creates the Uint8ClampedArray
            using var imageData = new ImageData((Uint8ClampedArray)__data!, w, h);
            ctx.PutImageData(imageData, 0, 0);
        }
        var bps = length / sw.Elapsed.TotalSeconds;
        await Log($"PutImageData: {length} bytes in {sw.ElapsedMilliseconds}ms at a rate of {Math.Round(bps / 1000000, 3)} MBps");
    }

    async Task Log(string msg = "", bool clear = false)
    {
        if (clear) _log = "";
        _log += msg + "\n";
        StateHasChanged();
        await Task.Delay(5);
    }
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            canvas = new HTMLCanvasElement(canvasRef);
            ctx = canvas.Get2DContext();
        }
    }
    public void Dispose()
    {
        ctx?.Dispose();
        canvas?.Dispose();
    }
    private async Task RunWithWorkers()
    {
        if (_running || canvas == null || ctx == null) return;
        _running = true;
        var sw = Stopwatch.StartNew();
        try
        {
            await Log("Running...", clear: true);
            var size = 2000;
            canvas.Width = size;
            canvas.Height = size;
            var data = await CreateMandelbrot(place, true, size, bpp: 4);
            ctx.PutImageBytes(data, size, size);
        }
        finally
        {
            _running = false;
            sw.Stop();
            var elapsed = sw.Elapsed;
            await Log($"Done: {elapsed}");
            StateHasChanged();
        }
    }
    private async Task Run()
    {
        if (_running || canvas == null || ctx == null) return;
        _running = true;
        var sw = Stopwatch.StartNew();
        try
        {
            await Log("Running...", clear: true);
            var size = 2000;
            canvas.Width = size;
            canvas.Height = size;
            var data = await CreateMandelbrot(place, false, size, bpp: 4);
            ctx.PutImageBytes(data, size, size);
        }
        finally
        {
            _running = false;
            sw.Stop();
            var elapsed = sw.Elapsed;
            await Log($"Done: {elapsed}");
            StateHasChanged();
        }
    }
    async Task<byte[]> CreateMandelbrot(MandelbrotPlace place, bool useWorkers, int _bitmapSize = 10000, int bpp = 3)
    {
        //var worker = sender as BackgroundWorker;
        var _iterations = place.Iterations;
        var _colorRed = place.ColorRed;
        var _colorGreen = place.ColorGreen;
        var _colorBlue = place.ColorBlue;
        var _centerX = place.CenterX;
        var _centerY = place.CenterY;
        var _scaling = place.Scaling;
        var _antiAliasing = place.AntiAliasing;
        var width = _bitmapSize;
        var height = _bitmapSize;
        var _start = DateTime.Now;
        var _drawX = _centerX - (_bitmapSize * _scaling) / (2 * _antiAliasing);
        var _drawY = _centerY - (_bitmapSize * _scaling) / (2 * _antiAliasing);
        // create shared buffer
        // Native (Default) > byte[]
        // Native ILGPU > byte[]
        // Blazor WASM Workers > SharedArrayBuffer
        // Blazor WASM Compute Shader > ArrayBuffer ????
        using var sharedArrayBuffer = new SharedArrayBuffer(width * bpp * height);
        //var buffer = new byte[width * bpp * height];
        //var renderChunkWidth = width / _renderChunks;
        var threadCount = useWorkers ? WebWorkerService.TaskPool.MaxPoolSize : 0;
        var blockHeight = threadCount == 0 ? height : (int)Math.Floor((double)height / (double)threadCount);
        var tasks = new List<Task>();
        for (var y = 0; y < height; y += blockHeight)
        {
            var heightLeft = height - y;
            var jobHeight = Math.Min(blockHeight, heightLeft);
            var startY = y;
            if (useWorkers)
            {
                var t = WebWorkerService.TaskPool.Run(() => ThreadInstanceWorkCombined(sharedArrayBuffer, width, height, bpp, jobHeight, startY, _drawX, _drawY, _scaling, _antiAliasing, _iterations, _colorRed, _colorGreen, _colorBlue));
                tasks.Add(t);
            }
            else
            {
                var t = ThreadInstanceWorkCombined(sharedArrayBuffer, width, height, bpp, jobHeight, startY, _drawX, _drawY, _scaling, _antiAliasing, _iterations, _colorRed, _colorGreen, _colorBlue);
                tasks.Add(t);
            }
        }
        await Task.WhenAll(tasks);
        using var uint8ArrayShared = new Uint8Array(sharedArrayBuffer);
        var buffer = uint8ArrayShared.ReadBytes();
        return buffer;
    }
    static async Task ThreadInstanceWorkCombined([WorkerTransfer] SharedArrayBuffer sharedArrayBuffer, int width, int height, int bpp, int jobHeight, int startY, double _drawX, double _drawY, double _scaling, ushort _antiAliasing, ushort _iterations, ushort _colorRed, ushort _colorGreen, ushort _colorBlue)
    {
        var chunkLength = jobHeight * width * bpp;
        var dataChunk = new byte[chunkLength];
        for (var y = startY; y < startY + jobHeight; y++)
        {
            for (var x = 0; x < width; x++)
            {
                double dx = _drawX + _scaling * x / _antiAliasing;
                double dy = _drawY + _scaling * y / _antiAliasing;
                //
                var mandelNumber = 0;
                double a = 0, aOld = 0, b = 0, c = 0;
                while (c <= 4 && mandelNumber < _iterations)
                {
                    a = a * a - b * b + dx;
                    b = 2 * aOld * b + dy;
                    aOld = a;
                    c = a * a + b * b;
                    mandelNumber++;
                }

                // The maximum number of iterations is set to prevent infinite calculations. When this number of iterations is reached to pixel is black.
                if (mandelNumber == _iterations)
                    continue;

                // Coloring of the pixel
                // BGR or BGRA
                var chunkY = y - startY;
                var offset = ((chunkY * height) + x) * bpp;
                switch (bpp)
                {
                    case 3:
                        dataChunk[offset + 0] = Convert.ToByte(mandelNumber * _colorBlue % 255);
                        dataChunk[offset + 1] = Convert.ToByte(mandelNumber * _colorGreen % 255);
                        dataChunk[offset + 2] = Convert.ToByte(mandelNumber * _colorRed % 255);
                        break;
                    case 4:
                        dataChunk[offset + 0] = Convert.ToByte(mandelNumber * _colorBlue % 255);
                        dataChunk[offset + 1] = Convert.ToByte(mandelNumber * _colorGreen % 255);
                        dataChunk[offset + 2] = Convert.ToByte(mandelNumber * _colorRed % 255);
                        dataChunk[offset + 3] = 255;
                        break;
                }
            }
        }
        // write the chunk byte array to the shared array buffer
        var chunkInsertPos = startY * width * bpp;
        using var uint8ArrayShared = new Uint8Array(sharedArrayBuffer);
        uint8ArrayShared.Set(dataChunk, chunkInsertPos);
    }
}

